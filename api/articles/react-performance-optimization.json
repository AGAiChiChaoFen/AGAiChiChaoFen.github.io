{"title":"React 性能优化实战","uid":"5e0227989484764c5b52c6e1c54e4493","slug":"react-performance-optimization","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/react-performance-optimization.json","keywords":null,"cover":"https://example.com/cover-images/react-performance.png","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>随着 React 应用变得越来越复杂，性能优化逐渐成为开发者关注的重点。React<br>提供了多种机制来帮助开发者优化性能，尤其是在大型应用中，优化的措施能够显著提升页面的加载速度和响应能力。本文将探讨如何通过合理的技术手段优化<br>React 应用的性能，并提供具体的实现方式。</p>\n<h1 id=\"1-避免不必要的重渲染\"><a href=\"#1-避免不必要的重渲染\" class=\"headerlink\" title=\"1. 避免不必要的重渲染\"></a>1. 避免不必要的重渲染</h1><p>React 中的不必要重渲染是性能瓶颈的常见来源。通过合理的优化策略，可以有效减少组件的重渲染次数，提高性能。</p>\n<h2 id=\"1-1-使用-React-memo-和-useMemo\"><a href=\"#1-1-使用-React-memo-和-useMemo\" class=\"headerlink\" title=\"1.1 使用 React.memo 和 useMemo\"></a>1.1 使用 <code>React.memo</code> 和 <code>useMemo</code></h2><p><code>React.memo</code> 用于优化函数组件，它会缓存组件的输出，只有当 props 改变时才会重新渲染。对于纯粹依赖 props 的组件，<code>React.memo</code><br>是一个非常有效的性能优化手段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">MyComponent</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(<span class=\"function\">(<span class=\"params\">&#123;name&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Component rendered&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>useMemo</code> 可以缓存计算结果，防止每次渲染都重新计算复杂的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">MyComponent</span> = (<span class=\"params\">&#123;items&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> expensiveCalculation = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> items.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">total, item</span>) =&gt;</span> total + item.<span class=\"property\">price</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;, [items]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Total: &#123;expensiveCalculation&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-使用-useCallback\"><a href=\"#1-2-使用-useCallback\" class=\"headerlink\" title=\"1.2 使用 useCallback\"></a>1.2 使用 <code>useCallback</code></h2><p><code>useCallback</code> 可以缓存回调函数，避免每次渲染时都重新生成函数实例。尤其在将函数作为 props 传递给子组件时，使用 <code>useCallback</code><br>可以避免子组件的无意义渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">ParentComponent</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> increment = <span class=\"title function_\">useCallback</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>), [count]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ChildComponent</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;increment&#125;/</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-代码分割与懒加载\"><a href=\"#2-代码分割与懒加载\" class=\"headerlink\" title=\"2. 代码分割与懒加载\"></a>2. 代码分割与懒加载</h1><p>在大型应用中，代码分割是优化性能的一个重要手段。React 提供了内置的 <code>React.lazy</code> 和 <code>Suspense</code> API，可以实现按需加载组件，减少首次加载的<br>JavaScript 包的大小。</p>\n<h2 id=\"2-1-使用-React-lazy-实现组件懒加载\"><a href=\"#2-1-使用-React-lazy-实现组件懒加载\" class=\"headerlink\" title=\"2.1 使用 React.lazy 实现组件懒加载\"></a>2.1 使用 <code>React.lazy</code> 实现组件懒加载</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">LazyComponent</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./LazyComponent&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">LazyComponent</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>Suspense</code> 组件用来包裹懒加载组件，在组件加载期间，<code>fallback</code> 会显示一个加载中的提示。</p>\n<h2 id=\"2-2-结合-Webpack-实现路由懒加载\"><a href=\"#2-2-结合-Webpack-实现路由懒加载\" class=\"headerlink\" title=\"2.2 结合 Webpack 实现路由懒加载\"></a>2.2 结合 Webpack 实现路由懒加载</h2><p>React Router 和 <code>React.lazy</code> 配合使用，可以按需加载不同路由的组件，减少首屏加载时的资源消耗。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Home</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./pages/Home&#x27;</span>));</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">About</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./pages/About&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">App</span> = (<span class=\"params\"></span>) =&gt; (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">Routes</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/&quot;</span> <span class=\"attr\">element</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">Home</span>/&gt;</span>&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;/about&quot;</span> <span class=\"attr\">element</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">About</span>/&gt;</span>&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Routes</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-虚拟化长列表\"><a href=\"#3-虚拟化长列表\" class=\"headerlink\" title=\"3. 虚拟化长列表\"></a>3. 虚拟化长列表</h1><p>在 React 应用中处理大量数据时，普通的列表渲染可能会导致性能问题，特别是在数据量非常大的情况下。虚拟化技术通过只渲染可见区域的元素，显著减少了<br>DOM 元素的数量。</p>\n<h2 id=\"3-1-使用-react-window-实现虚拟滚动\"><a href=\"#3-1-使用-react-window-实现虚拟滚动\" class=\"headerlink\" title=\"3.1 使用 react-window 实现虚拟滚动\"></a>3.1 使用 <code>react-window</code> 实现虚拟滚动</h2><p><code>react-window</code> 是一个轻量级的虚拟滚动库，适合用于长列表、长表格等场景。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-window</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>react-window</code> 渲染长列表：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">FixedSizeList</span> <span class=\"keyword\">as</span> <span class=\"title class_\">List</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-window&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">MyList</span> = (<span class=\"params\">&#123;items&#125;</span>) =&gt; (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">List</span> <span class=\"attr\">height</span>=<span class=\"string\">&#123;400&#125;</span> <span class=\"attr\">itemCount</span>=<span class=\"string\">&#123;items.length&#125;</span> <span class=\"attr\">itemSize</span>=<span class=\"string\">&#123;35&#125;</span> <span class=\"attr\">width</span>=<span class=\"string\">&#123;300&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;(&#123;index, style&#125;) =&gt; <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span>&gt;</span>&#123;items[index]&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">List</span>&gt;</span></span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>该方法确保只有可视区域的元素会被渲染，极大提高了性能。</p>\n<h1 id=\"4-服务端渲染-SSR-和静态站点生成-SSG\"><a href=\"#4-服务端渲染-SSR-和静态站点生成-SSG\" class=\"headerlink\" title=\"4. 服务端渲染 (SSR) 和静态站点生成 (SSG)\"></a>4. 服务端渲染 (SSR) 和静态站点生成 (SSG)</h1><p>对于需要快速加载的应用，服务端渲染 (SSR) 和静态站点生成 (SSG) 是提升性能的有效方案。React 的 <code>Next.js</code> 框架是实现 SSR 和<br>SSG 的热门解决方案，它能在服务器端渲染页面并将其发送到浏览器，减少了客户端的渲染压力。</p>\n<h2 id=\"4-1-使用-Next-js-实现-SSR\"><a href=\"#4-1-使用-Next-js-实现-SSR\" class=\"headerlink\" title=\"4.1 使用 Next.js 实现 SSR\"></a>4.1 使用 <code>Next.js</code> 实现 SSR</h2><p><code>Next.js</code> 通过 <code>getServerSideProps</code> 和 <code>getStaticProps</code> 等 API 支持服务端渲染和静态生成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pages/index.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getServerSideProps</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> res.<span class=\"title function_\">json</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">props</span>: &#123;data&#125;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Home</span> = (<span class=\"params\">&#123;data&#125;</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;JSON.stringify(data)&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">Home</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-图片优化\"><a href=\"#5-图片优化\" class=\"headerlink\" title=\"5. 图片优化\"></a>5. 图片优化</h1><p>图片的大小和加载速度会直接影响页面的渲染性能。通过合理的优化方法，能够减少图片加载的时间和带宽消耗。</p>\n<h2 id=\"5-1-图片懒加载\"><a href=\"#5-1-图片懒加载\" class=\"headerlink\" title=\"5.1 图片懒加载\"></a>5.1 图片懒加载</h2><p>使用 <code>loading=&quot;lazy&quot;</code> 属性可以实现原生的图片懒加载，只有当图片进入视口时才会加载。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;image.jpg&quot;</span> <span class=\"attr\">loading</span>=<span class=\"string\">&quot;lazy&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;Image&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-适配不同设备的图片格式\"><a href=\"#5-2-适配不同设备的图片格式\" class=\"headerlink\" title=\"5.2 适配不同设备的图片格式\"></a>5.2 适配不同设备的图片格式</h2><p>使用 <code>srcset</code> 和 <code>sizes</code> 属性可以根据不同的设备分辨率加载不同分辨率的图片，从而减少不必要的带宽消耗。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">src</span>=<span class=\"string\">&quot;image-small.jpg&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">srcset</span>=<span class=\"string\">&quot;image-large.jpg 1200w, image-medium.jpg 800w&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">sizes</span>=<span class=\"string\">&quot;(max-width: 600px) 100vw, 50vw&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">alt</span>=<span class=\"string\">&quot;Responsive image&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h1><p>React 性能优化是一项系统的工作，需要从多个维度入手，包括避免不必要的重渲染、代码分割、组件懒加载、虚拟化技术等。结合不同的优化方法，可以显著提升<br>React 应用的性能，提升用户体验。希望本文所介绍的优化技巧能为你的 React 项目带来帮助。</p>\n","feature":true,"text":"本文将分享在 React 应用中如何进行性能优化，涵盖了组件重渲染优化、虚拟化技术、代码分割等实践，帮助开发者提升应用的响应速度和用户体验。...","permalink":"/post/react-performance-optimization","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"前端开发","slug":"前端开发","count":4,"path":"api/categories/前端开发.json"},{"name":"性能优化","slug":"前端开发/性能优化","count":2,"path":"api/categories/前端开发/性能优化.json"}],"tags":[{"name":"React","slug":"React","count":1,"path":"api/tags/React.json"},{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"},{"name":"组件重渲染","slug":"组件重渲染","count":1,"path":"api/tags/组件重渲染.json"},{"name":"虚拟化","slug":"虚拟化","count":1,"path":"api/tags/虚拟化.json"},{"name":"代码分割","slug":"代码分割","count":1,"path":"api/tags/代码分割.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E9%87%8D%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">1. 避免不必要的重渲染</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E4%BD%BF%E7%94%A8-React-memo-%E5%92%8C-useMemo\"><span class=\"toc-text\">1.1 使用 React.memo 和 useMemo</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E4%BD%BF%E7%94%A8-useCallback\"><span class=\"toc-text\">1.2 使用 useCallback</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">2. 代码分割与懒加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E4%BD%BF%E7%94%A8-React-lazy-%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">2.1 使用 React.lazy 实现组件懒加载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E7%BB%93%E5%90%88-Webpack-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">2.2 结合 Webpack 实现路由懒加载</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E8%99%9A%E6%8B%9F%E5%8C%96%E9%95%BF%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">3. 虚拟化长列表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%BD%BF%E7%94%A8-react-window-%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8\"><span class=\"toc-text\">3.1 使用 react-window 实现虚拟滚动</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-SSR-%E5%92%8C%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9%E7%94%9F%E6%88%90-SSG\"><span class=\"toc-text\">4. 服务端渲染 (SSR) 和静态站点生成 (SSG)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E4%BD%BF%E7%94%A8-Next-js-%E5%AE%9E%E7%8E%B0-SSR\"><span class=\"toc-text\">4.1 使用 Next.js 实现 SSR</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">5. 图片优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">5.1 图片懒加载</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">5.2 适配不同设备的图片格式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6. 总结</span></a></li></ol>","author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"构建高效的即时通讯应用","uid":"a0e64d292df5c31580df175e37a4bef5","slug":"real-time-messaging-app","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/real-time-messaging-app.json","keywords":null,"cover":"https://example.com/cover-images/real-time-messaging.png","text":"本文将探讨如何设计和开发高效的即时通讯应用，涉及实时消息传输、WebSocket、消息队列、消息持久化等关键技术，帮助开发者构建流畅且高效的聊天系统。...","permalink":"/post/real-time-messaging-app","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"即时通讯","slug":"后端开发/即时通讯","count":1,"path":"api/categories/后端开发/即时通讯.json"}],"tags":[{"name":"WebSocket","slug":"WebSocket","count":3,"path":"api/tags/WebSocket.json"},{"name":"实时通信","slug":"实时通信","count":3,"path":"api/tags/实时通信.json"},{"name":"即时通讯","slug":"即时通讯","count":1,"path":"api/tags/即时通讯.json"},{"name":"消息队列","slug":"消息队列","count":1,"path":"api/tags/消息队列.json"},{"name":"聊天系统","slug":"聊天系统","count":1,"path":"api/tags/聊天系统.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"Java集合框架深度解析：从基础到进阶","uid":"a2962ecf74c5279b05ba5106b5b29eba","slug":"java-collections-guide","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/java-collections-guide.json","keywords":null,"cover":"https://example.com/cover-images/java-collections.png","text":"本文详细讲解了Java集合框架的各个核心组件，包括List、Set、Map等，深入分析其实现原理、使用场景及性能特点，帮助开发者更好地理解和应用Java集合。...","permalink":"/post/java-collections-guide","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"Java开发","slug":"Java开发","count":2,"path":"api/categories/Java开发.json"},{"name":"数据结构","slug":"Java开发/数据结构","count":1,"path":"api/categories/Java开发/数据结构.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Map","slug":"Map","count":2,"path":"api/tags/Map.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"集合框架","slug":"集合框架","count":2,"path":"api/tags/集合框架.json"},{"name":"编程","slug":"编程","count":2,"path":"api/tags/编程.json"},{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"},{"name":"List","slug":"List","count":1,"path":"api/tags/List.json"},{"name":"Set","slug":"Set","count":1,"path":"api/tags/Set.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true}}