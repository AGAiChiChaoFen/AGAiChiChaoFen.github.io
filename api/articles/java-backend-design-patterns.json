{"title":"设计模式与应用实践","uid":"ae0e22db0a4ce89b9bf3c9d683d2a2ae","slug":"java-backend-design-patterns","date":"2023-08-19T16:00:00.000Z","updated":"2023-08-24T16:00:00.000Z","comments":true,"path":"api/articles/java-backend-design-patterns.json","keywords":null,"cover":null,"content":"<h1 id=\"Java-后端开发中的常见设计模式\"><a href=\"#Java-后端开发中的常见设计模式\" class=\"headerlink\" title=\"Java 后端开发中的常见设计模式\"></a>Java 后端开发中的常见设计模式</h1><p>在软件开发中，设计模式是一种经过验证的、具有高度通用性的解决方案，它能够帮助开发者在面对复杂问题时找到高效且可维护的解决方案。对于<br>Java 后端开发者来说，设计模式不仅可以提高代码的可重用性和可扩展性，还能帮助开发者更好地理解系统的结构和架构。本文将介绍<br>Java 后端开发中最常见的几种设计模式，并分享它们的应用场景。</p>\n<h2 id=\"单例模式（Singleton-Pattern）\"><a href=\"#单例模式（Singleton-Pattern）\" class=\"headerlink\" title=\"单例模式（Singleton Pattern）\"></a>单例模式（Singleton Pattern）</h2><p>单例模式确保某个类只有一个实例，并提供全局访问点。它常用于需要全局共享资源或控制访问的场景，例如数据库连接池、日志记录器等。</p>\n<h3 id=\"单例模式的实现\"><a href=\"#单例模式的实现\" class=\"headerlink\" title=\"单例模式的实现\"></a>单例模式的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例模式的核心思想是通过 <code>getInstance</code> 方法来确保类的实例唯一性。在多线程环境下，<code>synchronized</code> 关键字可以保证线程安全。</p>\n<h2 id=\"工厂模式（Factory-Pattern）\"><a href=\"#工厂模式（Factory-Pattern）\" class=\"headerlink\" title=\"工厂模式（Factory Pattern）\"></a>工厂模式（Factory Pattern）</h2><p>工厂模式是创建型设计模式的一种，它提供一个创建对象的接口，但由子类决定实例化哪一个类。工厂模式常用于需要根据不同条件创建不同对象的情况。</p>\n<h3 id=\"工厂模式的实现\"><a href=\"#工厂模式的实现\" class=\"headerlink\" title=\"工厂模式的实现\"></a>工厂模式的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteProductA</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product A created&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteProductB</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">create</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product B created&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProductFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Product <span class=\"title function_\">getProduct</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">&quot;A&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteProductA</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">&quot;B&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConcreteProductB</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂模式通过 <code>ProductFactory</code> 类来创建不同的产品实例。根据传入的类型，工厂方法决定返回哪种具体产品。</p>\n<h2 id=\"观察者模式（Observer-Pattern）\"><a href=\"#观察者模式（Observer-Pattern）\" class=\"headerlink\" title=\"观察者模式（Observer Pattern）\"></a>观察者模式（Observer Pattern）</h2><p>观察者模式定义了对象之间的一对多依赖关系，使得当一个对象的状态发生改变时，所有依赖它的对象都能自动收到通知并更新。它广泛应用于事件处理和消息通知系统中。</p>\n<h3 id=\"观察者模式的实现\"><a href=\"#观察者模式的实现\" class=\"headerlink\" title=\"观察者模式的实现\"></a>观察者模式的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(String message)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteObserver</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ConcreteObserver</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">&quot; received message: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addObserver</span><span class=\"params\">(Observer observer)</span> &#123;</span><br><span class=\"line\">        observers.add(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">removeObserver</span><span class=\"params\">(Observer observer)</span> &#123;</span><br><span class=\"line\">        observers.remove(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">notifyObservers</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Observer observer : observers) &#123;</span><br><span class=\"line\">            observer.update(message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在观察者模式中，<code>Subject</code> 维护一个观察者列表，当状态发生变化时，通知所有注册的观察者。每个观察者根据其自身逻辑处理接收到的消息。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>设计模式是后端开发中非常重要的一个部分，它帮助开发者在设计系统时更好地管理复杂性，减少重复代码，提高系统的可维护性。在 Java<br>后端开发中，单例模式、工厂模式和观察者模式是常见的设计模式，它们各自有不同的应用场景，了解并灵活运用这些模式将大大提高开发效率和代码质量。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p><strong>提示</strong><br>对于初学者来说，学习和理解设计模式可能会有些难度，但通过多做练习并在实际项目中应用，逐渐能够掌握这些模式的精髓。</p>\n</div>\n<details class=\"custom-details\">\n<summary>更多学习资源</summary>\n<p>如果您对设计模式感兴趣，建议参考《设计模式：可复用面向对象软件的基础》这本书，它详细介绍了各种设计模式及其应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码展示</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 核心代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</details>\n<pre><code>\n</code></pre>\n","text":"本文深入探讨常见的设计模式及其应用，包括单例模式、工厂模式、观察者模式等，帮助开发者提升系统的可维护性、扩展性和复用性。...","permalink":"/post/java-backend-design-patterns","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"软件设计","slug":"软件设计","count":1,"path":"api/categories/软件设计.json"},{"name":"架构设计","slug":"软件设计/架构设计","count":1,"path":"api/categories/软件设计/架构设计.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"},{"name":"单例模式","slug":"单例模式","count":1,"path":"api/tags/单例模式.json"},{"name":"工厂模式","slug":"工厂模式","count":1,"path":"api/tags/工厂模式.json"},{"name":"观察者模式","slug":"观察者模式","count":1,"path":"api/tags/观察者模式.json"},{"name":"结构模式","slug":"结构模式","count":1,"path":"api/tags/结构模式.json"},{"name":"行为模式","slug":"行为模式","count":1,"path":"api/tags/行为模式.json"},{"name":"开发技巧","slug":"开发技巧","count":1,"path":"api/tags/开发技巧.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Java 后端开发中的常见设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Pattern%EF%BC%89\"><span class=\"toc-text\">单例模式（Singleton Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">单例模式的实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89\"><span class=\"toc-text\">工厂模式（Factory Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">工厂模式的实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89\"><span class=\"toc-text\">观察者模式（Observer Pattern）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">观察者模式的实现</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring Boot性能优化与最佳实践","uid":"480c3db8fc24ba125bf56f7e20566f0a","slug":"spring-boot-microservices-performance","date":"2024-01-24T16:00:00.000Z","updated":"2024-01-31T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-microservices-performance.json","keywords":null,"cover":"https://example.com/cover-images/spring-boot-performance.png","text":"本文深入分析了如何优化Spring Boot应用的性能，涵盖了数据库优化、缓存策略、线程池管理等方面的最佳实践，并提供了详细的性能调优技巧。...","permalink":"/post/spring-boot-microservices-performance","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"性能优化","slug":"后端开发/性能优化","count":6,"path":"api/categories/后端开发/性能优化.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"},{"name":"异步处理","slug":"异步处理","count":3,"path":"api/tags/异步处理.json"},{"name":"数据库优化","slug":"数据库优化","count":3,"path":"api/tags/数据库优化.json"},{"name":"缓存策略","slug":"缓存策略","count":5,"path":"api/tags/缓存策略.json"},{"name":"JVM调优","slug":"JVM调优","count":3,"path":"api/tags/JVM调优.json"},{"name":"线程池管理","slug":"线程池管理","count":2,"path":"api/tags/线程池管理.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"Spring Boot与Vue.js前后端分离架构深度实践","uid":"0e7fd81b7583e28a57e49354c17b48be","slug":"spring-boot-vue-integration-advanced","date":"2023-08-19T16:00:00.000Z","updated":"2023-08-24T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-vue-integration-advanced.json","keywords":null,"cover":"https://example.com/cover-images/fullstack-security-arch.png","text":"Spring Boot与Vue.js前后端分离架构深度实践架构演进：从单体到分离式架构 现代Web开发已全面进入前后端分离时代，这种架构模式带来三大核心优势： ...","permalink":"/post/spring-boot-vue-integration-advanced","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"全栈开发","slug":"全栈开发","count":2,"path":"api/categories/全栈开发.json"},{"name":"云原生架构","slug":"全栈开发/云原生架构","count":1,"path":"api/categories/全栈开发/云原生架构.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"Vue3","slug":"Vue3","count":1,"path":"api/tags/Vue3.json"},{"name":"安全跨域","slug":"安全跨域","count":1,"path":"api/tags/安全跨域.json"},{"name":"OpenAPI","slug":"OpenAPI","count":1,"path":"api/tags/OpenAPI.json"},{"name":"Axios拦截器","slug":"Axios拦截器","count":1,"path":"api/tags/Axios拦截器.json"},{"name":"Nginx反向代理","slug":"Nginx反向代理","count":1,"path":"api/tags/Nginx反向代理.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true}}