{"title":"深入讲解 Java Map 的实现原理","uid":"e53806ef11a043e56d7ec2f23b4d7254","slug":"deep-dive-into-map-implementation-in-java","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/deep-dive-into-map-implementation-in-java.json","keywords":null,"cover":"https://example.com/cover-images/map-implementation.png","content":"<h3 id=\"深入讲解-Java-Map-的实现原理\"><a href=\"#深入讲解-Java-Map-的实现原理\" class=\"headerlink\" title=\"深入讲解 Java Map 的实现原理\"></a>深入讲解 Java Map 的实现原理</h3><p>Java 中的 <code>Map</code> 接口是集合框架的重要组成部分，它为我们提供了键值对存储的能力。不同于 <code>List</code> 和 <code>Set</code>，<code>Map</code> 以“键-值”对的形式存储数据，其中每个键只能映射到一个值，但不同的键可以对应相同的值。常见的 <code>Map</code> 实现包括 <code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code> 和 <code>Hashtable</code> 等。本文将从底层结构、工作原理、性能特点等多个角度深入探讨这些实现的具体原理。</p>\n<h3 id=\"1-Map-接口概述\"><a href=\"#1-Map-接口概述\" class=\"headerlink\" title=\"1. Map 接口概述\"></a>1. Map 接口概述</h3><p><code>Map</code> 是 Java 集合框架中用于存储键值对的接口，它有着以下主要操作：</p>\n<ul>\n<li><strong>插入</strong>：<code>put(K key, V value)</code> 将键值对存入 <code>Map</code>。</li>\n<li><strong>查找</strong>：<code>get(Object key)</code> 根据键查找对应的值。</li>\n<li><strong>删除</strong>：<code>remove(Object key)</code> 删除指定键的键值对。</li>\n<li><strong>判断是否包含键或值</strong>：<code>containsKey(Object key)</code>，<code>containsValue(Object value)</code>。</li>\n<li><strong>大小</strong>：<code>size()</code> 返回键值对的数量。</li>\n</ul>\n<p>常见的 <code>Map</code> 实现类有：</p>\n<ul>\n<li><code>HashMap</code>：基于哈希表实现，具有较高的查询效率。</li>\n<li><code>TreeMap</code>：基于红黑树实现，按键的自然顺序或比较器排序。</li>\n<li><code>LinkedHashMap</code>：维护插入顺序的哈希表实现。</li>\n<li><code>Hashtable</code>：线程安全的哈希表实现。</li>\n</ul>\n<h3 id=\"2-HashMap-的实现原理\"><a href=\"#2-HashMap-的实现原理\" class=\"headerlink\" title=\"2. HashMap 的实现原理\"></a>2. HashMap 的实现原理</h3><p><code>HashMap</code> 是最常用的 <code>Map</code> 实现，它基于哈希表来存储数据。<code>HashMap</code> 的底层结构是一个数组，每个数组元素叫做“桶”。当多个键映射到相同的桶时，<code>HashMap</code> 会使用链表来存储这些元素。</p>\n<h4 id=\"2-1-哈希值计算\"><a href=\"#2-1-哈希值计算\" class=\"headerlink\" title=\"2.1 哈希值计算\"></a>2.1 哈希值计算</h4><p><code>HashMap</code> 的每个键都有一个 <code>hashCode</code> 值，通过该值计算数组索引。<code>HashMap</code> 使用以下公式计算桶的索引位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index = (n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>n</code> 是数组的长度，<code>hash</code> 是键的 <code>hashCode</code> 经过扰动函数处理后的结果。这样可以有效避免哈希冲突，提高存储和查找的效率。</p>\n<h4 id=\"2-2-处理哈希冲突\"><a href=\"#2-2-处理哈希冲突\" class=\"headerlink\" title=\"2.2 处理哈希冲突\"></a>2.2 处理哈希冲突</h4><p>哈希冲突是指不同的键计算出的哈希值相同，这会导致它们被放入同一个桶中。<code>HashMap</code> 采用链表或红黑树来解决冲突：</p>\n<ul>\n<li><strong>链表</strong>：当哈希冲突较少时，<code>HashMap</code> 会在同一个桶中用链表来存储多个键值对。</li>\n<li><strong>红黑树</strong>：从 JDK 1.8 开始，如果某个桶中的元素数量超过 8 个，且桶的总容量大于 64，<code>HashMap</code> 会将链表转换为红黑树，以提升查询性能。</li>\n</ul>\n<h4 id=\"2-3-扩容机制\"><a href=\"#2-3-扩容机制\" class=\"headerlink\" title=\"2.3 扩容机制\"></a>2.3 扩容机制</h4><p><code>HashMap</code> 会根据元素的数量动态调整数组的大小。默认初始容量为 16，负载因子为 0.75。当元素数量超过容量的 75% 时，<code>HashMap</code><br>会进行扩容，通常是将容量翻倍。扩容过程中，所有键值对需要重新计算哈希值并移动到新的数组位置，这可能导致一定的性能开销。</p>\n<hr>\n<h3 id=\"3-TreeMap-的实现原理\"><a href=\"#3-TreeMap-的实现原理\" class=\"headerlink\" title=\"3. TreeMap 的实现原理\"></a>3. TreeMap 的实现原理</h3><p><code>TreeMap</code> 是一个基于红黑树实现的 <code>Map</code>，它的键值对会根据键的自然顺序或通过指定的比较器进行排序。与 <code>HashMap</code> 不同，<br><code>TreeMap</code> 保证了存储元素的顺序。</p>\n<h4 id=\"3-1-红黑树\"><a href=\"#3-1-红黑树\" class=\"headerlink\" title=\"3.1 红黑树\"></a>3.1 红黑树</h4><p>红黑树是一种自平衡的二叉搜索树，它通过一些规则（如每个节点的颜色、根节点为黑色、路径上黑色节点的数量相同等）来保持平衡，保证插入、删除和查找操作的时间复杂度为<br>O(log n)。</p>\n<h4 id=\"3-2-有序性\"><a href=\"#3-2-有序性\" class=\"headerlink\" title=\"3.2 有序性\"></a>3.2 有序性</h4><p><code>TreeMap</code> 具有天然的排序能力。当我们插入元素时，它会根据键的顺序将元素排序。可以通过指定一个自定义的比较器来改变排序规则。</p>\n<hr>\n<h3 id=\"4-LinkedHashMap-的实现原理\"><a href=\"#4-LinkedHashMap-的实现原理\" class=\"headerlink\" title=\"4. LinkedHashMap 的实现原理\"></a>4. LinkedHashMap 的实现原理</h3><p><code>LinkedHashMap</code> 是 <code>HashMap</code> 的一个变种，它不仅支持哈希表查找，还通过双向链表维护插入顺序或访问顺序。</p>\n<h4 id=\"4-1-顺序控制\"><a href=\"#4-1-顺序控制\" class=\"headerlink\" title=\"4.1 顺序控制\"></a>4.1 顺序控制</h4><p><code>LinkedHashMap</code> 维护了一个双向链表，链表中的节点按照元素的插入顺序或者访问顺序排列。默认情况下，<code>LinkedHashMap</code><br>按照插入顺序维护元素的顺序，但如果设置 <code>accessOrder = true</code>，则会按照访问顺序进行排列。</p>\n<h4 id=\"4-2-应用场景\"><a href=\"#4-2-应用场景\" class=\"headerlink\" title=\"4.2 应用场景\"></a>4.2 应用场景</h4><p><code>LinkedHashMap</code> 适用于需要维持元素顺序的场景，如缓存系统（例如，最近最少使用（LRU）缓存）。在这种情况下，可以结合<br><code>LinkedHashMap</code> 的 <code>removeEldestEntry</code> 方法来实现 LRU 缓存。</p>\n<hr>\n<h3 id=\"5-Hashtable-的实现原理\"><a href=\"#5-Hashtable-的实现原理\" class=\"headerlink\" title=\"5. Hashtable 的实现原理\"></a>5. Hashtable 的实现原理</h3><p><code>Hashtable</code> 是 <code>HashMap</code> 的早期版本，它也采用哈希表存储数据，但与 <code>HashMap</code> 不同的是，<code>Hashtable</code> 是线程安全的。它通过<br><code>synchronized</code> 关键字对方法进行同步，确保线程安全。然而，由于 <code>Hashtable</code> 的性能开销较大，现代 Java 开发中更推荐使用<br><code>ConcurrentHashMap</code> 来代替 <code>Hashtable</code>。</p>\n<hr>\n<h3 id=\"6-性能对比\"><a href=\"#6-性能对比\" class=\"headerlink\" title=\"6. 性能对比\"></a>6. 性能对比</h3><table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>查找时间复杂度</th>\n<th>插入时间复杂度</th>\n<th>删除时间复杂度</th>\n<th>线程安全</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>HashMap</code></td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>否</td>\n<td>高效、无序</td>\n</tr>\n<tr>\n<td><code>TreeMap</code></td>\n<td>O(log n)</td>\n<td>O(log n)</td>\n<td>O(log n)</td>\n<td>否</td>\n<td>有序、排序</td>\n</tr>\n<tr>\n<td><code>LinkedHashMap</code></td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>否</td>\n<td>有序、插入顺序</td>\n</tr>\n<tr>\n<td><code>Hashtable</code></td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>是</td>\n<td>线程安全、性能较差</td>\n</tr>\n</tbody></table>\n<p>通过表格可以看到，不同实现的性能特点不同，选择时需要根据实际需求进行权衡。</p>\n<hr>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><p>Java 中的 <code>Map</code> 接口有多种实现，每种实现都有其特点和适用场景。<code>HashMap</code> 适用于大多数无序数据的存储，<code>TreeMap</code> 适合需要排序的场景，<br><code>LinkedHashMap</code> 则适用于保持顺序的场合。在并发场景中，可以选择 <code>ConcurrentHashMap</code>。理解不同实现的原理，可以帮助我们在项目中做出更合适的选择。</p>\n<hr>\n<p>通过本文的分析，您应该对 Java 中常见的 <code>Map</code> 实现有了更深入的了解。希望对您在实际开发中选择合适的数据结构提供一些帮助。</p>\n","feature":true,"text":"本文深入讲解 Java 中 `Map` 接口的实现原理，重点分析 `HashMap`、`TreeMap`、`LinkedHashMap` 等常见实现，探索它们的工作机制、性能特点及优化策略。...","permalink":"/post/deep-dive-into-map-implementation-in-java","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"数据结构","slug":"后端开发/数据结构","count":1,"path":"api/categories/后端开发/数据结构.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Map","slug":"Map","count":2,"path":"api/tags/Map.json"},{"name":"HashMap","slug":"HashMap","count":1,"path":"api/tags/HashMap.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"集合框架","slug":"集合框架","count":2,"path":"api/tags/集合框架.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3-Java-Map-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">深入讲解 Java Map 的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Map-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Map 接口概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-HashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2. HashMap 的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E5%93%88%E5%B8%8C%E5%80%BC%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">2.1 哈希值计算</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%84%E7%90%86%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">2.2 处理哈希冲突</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.3 扩容机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-TreeMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3. TreeMap 的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-%E7%BA%A2%E9%BB%91%E6%A0%91\"><span class=\"toc-text\">3.1 红黑树</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-%E6%9C%89%E5%BA%8F%E6%80%A7\"><span class=\"toc-text\">3.2 有序性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-LinkedHashMap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4. LinkedHashMap 的实现原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">4.1 顺序控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">4.2 应用场景</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Hashtable-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">5. Hashtable 的实现原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">6. 性能对比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">7. 总结</span></a></li></ol>","author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"一些实用的 CSS 技巧提升现代网页设计","uid":"f7d96ebdf4d2c1acf5bfaff97afac0ef","slug":"css-tips-and-tricks-for-modern-web-design","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/css-tips-and-tricks-for-modern-web-design.json","keywords":null,"cover":"https://example.com/cover-images/css-tips.png","text":"本文将分享一些实用的 CSS 技巧，帮助开发者提升网页设计的效率和效果，涵盖了布局、响应式设计、动画等方面的技巧。...","permalink":"/post/css-tips-and-tricks-for-modern-web-design","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"前端开发","slug":"前端开发","count":4,"path":"api/categories/前端开发.json"},{"name":"CSS技巧","slug":"前端开发/CSS技巧","count":1,"path":"api/categories/前端开发/CSS技巧.json"}],"tags":[{"name":"CSS","slug":"CSS","count":1,"path":"api/tags/CSS.json"},{"name":"网页设计","slug":"网页设计","count":2,"path":"api/tags/网页设计.json"},{"name":"响应式设计","slug":"响应式设计","count":2,"path":"api/tags/响应式设计.json"},{"name":"CSS动画","slug":"CSS动画","count":1,"path":"api/tags/CSS动画.json"},{"name":"布局技巧","slug":"布局技巧","count":1,"path":"api/tags/布局技巧.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"如何搭建一个简单的聊天室（基于 WebSocket）","uid":"b0b196b8cb2c43915438318c4df4a70f","slug":"building-a-chatroom-with-websocket","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/building-a-chatroom-with-websocket.json","keywords":null,"cover":"https://example.com/cover-images/chatroom.png","text":"本文将通过一步步的指导，教你如何使用 WebSocket 技术搭建一个简单的聊天室应用，包括客户端和服务器端的实现。...","permalink":"/post/building-a-chatroom-with-websocket","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"实时通信","slug":"后端开发/实时通信","count":2,"path":"api/categories/后端开发/实时通信.json"}],"tags":[{"name":"WebSocket","slug":"WebSocket","count":3,"path":"api/tags/WebSocket.json"},{"name":"聊天室","slug":"聊天室","count":1,"path":"api/tags/聊天室.json"},{"name":"实时通信","slug":"实时通信","count":3,"path":"api/tags/实时通信.json"},{"name":"Node.js","slug":"Node-js","count":1,"path":"api/tags/Node-js.json"},{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true}}