{"title":"Spring Boot 缓存优化最佳实践","uid":"3d4b54f4308b00837c10ccdd2030998e","slug":"spring-boot-cache-optimization","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-cache-optimization.json","keywords":null,"cover":"https://example.com/cover-images/spring-boot-cache.png","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>随着应用规模的增长和用户数量的增加，如何提高系统的响应速度和吞吐量，成为了开发者面临的巨大挑战。缓存作为一种提升性能的常见手段，能够有效减轻数据库负载和提高数据访问速度。Spring<br>Boot 提供了灵活的缓存支持，开发者可以通过集成不同的缓存框架，轻松实现高效的缓存机制。</p>\n<p>本文将介绍 Spring Boot 缓存优化的最佳实践，涵盖缓存策略的选择、常见缓存框架的集成与性能优化技巧，帮助开发者提升缓存处理的效率，避免缓存雪崩、缓存击穿等常见问题。</p>\n<h1 id=\"1-启用-Spring-Boot-缓存支持\"><a href=\"#1-启用-Spring-Boot-缓存支持\" class=\"headerlink\" title=\"1. 启用 Spring Boot 缓存支持\"></a>1. 启用 Spring Boot 缓存支持</h1><p>Spring Boot 提供了对缓存的开箱即用支持。只需在配置类上添加 <code>@EnableCaching</code> 注解，Spring Boot 就会自动配置缓存功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CacheApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(CacheApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-缓存策略的选择\"><a href=\"#2-缓存策略的选择\" class=\"headerlink\" title=\"2. 缓存策略的选择\"></a>2. 缓存策略的选择</h1><p>不同的业务场景可能需要不同的缓存策略。常见的缓存策略包括：</p>\n<h2 id=\"2-1-读写缓存\"><a href=\"#2-1-读写缓存\" class=\"headerlink\" title=\"2.1 读写缓存\"></a>2.1 读写缓存</h2><p>在读写缓存策略中，当读取数据时，如果缓存中存在，则从缓存中获取；否则，读取数据库并将数据存入缓存；写操作时，直接更新缓存和数据库。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟从数据库读取用户数据</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(id, <span class=\"string\">&quot;User&quot;</span> + id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CachePut(value = &quot;users&quot;, key = &quot;#user.id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">updateUser</span><span class=\"params\">(User user)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟更新用户信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CacheEvict(value = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteUser</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟删除用户信息</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-只读缓存\"><a href=\"#2-2-只读缓存\" class=\"headerlink\" title=\"2.2 只读缓存\"></a>2.2 只读缓存</h2><p>只读缓存策略适用于那些不经常变化的数据。读取时直接从缓存中获取数据，更新时不再操作缓存。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;products&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Product <span class=\"title function_\">getProductById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟从数据库获取产品数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Product</span>(id, <span class=\"string\">&quot;Product&quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-异步缓存\"><a href=\"#2-3-异步缓存\" class=\"headerlink\" title=\"2.3 异步缓存\"></a>2.3 异步缓存</h2><p>如果缓存的操作是计算密集型的，可以考虑使用异步缓存。Spring Boot 可以与 <code>@Async</code> 注解结合使用，将缓存操作放到独立的线程中执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Async</span></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;expensiveData&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Future&lt;Data&gt; <span class=\"title function_\">calculateExpensiveData</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟计算一个昂贵的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncResult</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">Data</span>(id, <span class=\"string\">&quot;Expensive Data&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-常见缓存框架集成\"><a href=\"#3-常见缓存框架集成\" class=\"headerlink\" title=\"3. 常见缓存框架集成\"></a>3. 常见缓存框架集成</h1><p>Spring Boot 支持多种缓存框架的集成，常用的缓存框架包括 Redis、Caffeine 和 Ehcache。</p>\n<h2 id=\"3-1-Redis-缓存集成\"><a href=\"#3-1-Redis-缓存集成\" class=\"headerlink\" title=\"3.1 Redis 缓存集成\"></a>3.1 Redis 缓存集成</h2><p>Redis 是一个高性能的键值对存储，广泛应用于分布式缓存场景。Spring Boot 提供了与 Redis 的集成支持，开发者可以快速实现基于<br>Redis 的缓存。</p>\n<h3 id=\"3-1-1-配置-Redis-缓存\"><a href=\"#3-1-1-配置-Redis-缓存\" class=\"headerlink\" title=\"3.1.1 配置 Redis 缓存\"></a>3.1.1 配置 Redis 缓存</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">cache:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"string\">localhost</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">6379</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-2-使用-Redis-缓存\"><a href=\"#3-1-2-使用-Redis-缓存\" class=\"headerlink\" title=\"3.1.2 使用 Redis 缓存\"></a>3.1.2 使用 Redis 缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟从数据库查询用户信息</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(id, <span class=\"string\">&quot;User&quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-Caffeine-缓存集成\"><a href=\"#3-2-Caffeine-缓存集成\" class=\"headerlink\" title=\"3.2 Caffeine 缓存集成\"></a>3.2 Caffeine 缓存集成</h2><p>Caffeine 是一个基于 Java 8 特性的高效缓存库。它提供了快速的内存缓存，并且支持异步加载和过期策略。</p>\n<h3 id=\"3-2-1-配置-Caffeine-缓存\"><a href=\"#3-2-1-配置-Caffeine-缓存\" class=\"headerlink\" title=\"3.2.1 配置 Caffeine 缓存\"></a>3.2.1 配置 Caffeine 缓存</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">cache:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">caffeine</span></span><br><span class=\"line\">  <span class=\"attr\">caffeine:</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span> <span class=\"string\">maximumSize=1000,expireAfterAccess=600s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-使用-Caffeine-缓存\"><a href=\"#3-2-2-使用-Caffeine-缓存\" class=\"headerlink\" title=\"3.2.2 使用 Caffeine 缓存\"></a>3.2.2 使用 Caffeine 缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;items&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Item <span class=\"title function_\">getItemById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟从数据库查询数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Item</span>(id, <span class=\"string\">&quot;Item&quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-Ehcache-缓存集成\"><a href=\"#3-3-Ehcache-缓存集成\" class=\"headerlink\" title=\"3.3 Ehcache 缓存集成\"></a>3.3 Ehcache 缓存集成</h2><p>Ehcache 是一种广泛使用的 Java 缓存框架，支持持久化存储和分布式缓存。</p>\n<h3 id=\"3-3-1-配置-Ehcache-缓存\"><a href=\"#3-3-1-配置-Ehcache-缓存\" class=\"headerlink\" title=\"3.3.1 配置 Ehcache 缓存\"></a>3.3.1 配置 Ehcache 缓存</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">cache:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ehcache</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-2-使用-Ehcache-缓存\"><a href=\"#3-3-2-使用-Ehcache-缓存\" class=\"headerlink\" title=\"3.3.2 使用 Ehcache 缓存\"></a>3.3.2 使用 Ehcache 缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;orders&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Order <span class=\"title function_\">getOrderById</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟从数据库查询订单</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Order</span>(id, <span class=\"string\">&quot;Order&quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-缓存性能优化\"><a href=\"#4-缓存性能优化\" class=\"headerlink\" title=\"4. 缓存性能优化\"></a>4. 缓存性能优化</h1><p>尽管缓存可以显著提高系统性能，但不当的缓存配置可能导致性能瓶颈或不必要的资源浪费。以下是一些缓存性能优化的技巧：</p>\n<h2 id=\"4-1-设置合理的缓存过期策略\"><a href=\"#4-1-设置合理的缓存过期策略\" class=\"headerlink\" title=\"4.1 设置合理的缓存过期策略\"></a>4.1 设置合理的缓存过期策略</h2><p>合理的缓存过期时间可以防止缓存击穿和缓存雪崩。可以根据数据的变化频率设置过期时间，减少不必要的缓存更新。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">cache:</span></span><br><span class=\"line\">    <span class=\"attr\">caffeine:</span></span><br><span class=\"line\">      <span class=\"attr\">spec:</span> <span class=\"string\">maximumSize=1000,expireAfterWrite=10m</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-使用多级缓存\"><a href=\"#4-2-使用多级缓存\" class=\"headerlink\" title=\"4.2 使用多级缓存\"></a>4.2 使用多级缓存</h2><p>对于不同类型的数据，可以使用不同层级的缓存。例如，可以将热点数据缓存到内存中，将较少访问的数据缓存到 Redis 中，以优化缓存性能。</p>\n<h2 id=\"4-3-避免缓存击穿\"><a href=\"#4-3-避免缓存击穿\" class=\"headerlink\" title=\"4.3 避免缓存击穿\"></a>4.3 避免缓存击穿</h2><p>缓存击穿是指缓存中没有数据时，请求直接访问数据库。在高并发情况下，可能导致数据库压力增大。为避免缓存击穿，可以使用加锁策略或双重检查机制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Cacheable(value = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"title function_\">getUserByIdWithLock</span><span class=\"params\">(Long id)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> findUserInCache(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            user = databaseQuery(id);</span><br><span class=\"line\">            cacheUser(id, user);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-4-使用分布式锁防止缓存雪崩\"><a href=\"#4-4-使用分布式锁防止缓存雪崩\" class=\"headerlink\" title=\"4.4 使用分布式锁防止缓存雪崩\"></a>4.4 使用分布式锁防止缓存雪崩</h2><p>缓存雪崩是指缓存大规模失效，导致大量请求同时访问数据库，给数据库带来巨大的压力。可以通过分布式锁策略，避免大规模的缓存失效。</p>\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5. 结语\"></a>5. 结语</h1><p>Spring Boot<br>提供了灵活且强大的缓存机制，开发者可以根据不同的需求选择合适的缓存策略和缓存框架。通过合理配置缓存和优化缓存策略，可以显著提高系统的性能和吞吐量。然而，缓存的使用需要谨慎，需要合理设计过期策略、避免缓存击穿和雪崩，确保系统在高并发场景下的稳定性和可用性。</p>\n","feature":true,"text":"本文探讨了如何在 Spring Boot 中实现高效的缓存机制，包括缓存策略的选择、常见缓存框架的集成以及缓存性能优化技巧，帮助开发者提升系统性能。...","permalink":"/post/spring-boot-cache-optimization","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"性能优化","slug":"后端开发/性能优化","count":6,"path":"api/categories/后端开发/性能优化.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"缓存策略","slug":"缓存策略","count":5,"path":"api/tags/缓存策略.json"},{"name":"性能调优","slug":"性能调优","count":2,"path":"api/tags/性能调优.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"},{"name":"缓存优化","slug":"缓存优化","count":1,"path":"api/tags/缓存优化.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E5%90%AF%E7%94%A8-Spring-Boot-%E7%BC%93%E5%AD%98%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">1. 启用 Spring Boot 缓存支持</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">2. 缓存策略的选择</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E8%AF%BB%E5%86%99%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2.1 读写缓存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2.2 只读缓存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2.3 异步缓存</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90\"><span class=\"toc-text\">3. 常见缓存框架集成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Redis-%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90\"><span class=\"toc-text\">3.1 Redis 缓存集成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E9%85%8D%E7%BD%AE-Redis-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.1.1 配置 Redis 缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-%E4%BD%BF%E7%94%A8-Redis-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.1.2 使用 Redis 缓存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-Caffeine-%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90\"><span class=\"toc-text\">3.2 Caffeine 缓存集成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E9%85%8D%E7%BD%AE-Caffeine-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.2.1 配置 Caffeine 缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E4%BD%BF%E7%94%A8-Caffeine-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.2.2 使用 Caffeine 缓存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-Ehcache-%E7%BC%93%E5%AD%98%E9%9B%86%E6%88%90\"><span class=\"toc-text\">3.3 Ehcache 缓存集成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-%E9%85%8D%E7%BD%AE-Ehcache-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.3.1 配置 Ehcache 缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E4%BD%BF%E7%94%A8-Ehcache-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.3.2 使用 Ehcache 缓存</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E7%BC%93%E5%AD%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4. 缓存性能优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E8%AE%BE%E7%BD%AE%E5%90%88%E7%90%86%E7%9A%84%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.1 设置合理的缓存过期策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">4.2 使用多级缓存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">4.3 避免缓存击穿</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">4.4 使用分布式锁防止缓存雪崩</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E7%BB%93%E8%AF%AD\"><span class=\"toc-text\">5. 结语</span></a></li></ol>","author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"软件设计教程：从需求到架构","uid":"f9dcc5cb0e2169488ba353001fae5396","slug":"software-design-tutorial","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/software-design-tutorial.json","keywords":null,"cover":"https://example.com/cover-images/software-design.png","text":"本文将为你提供从需求分析到系统架构设计的全面软件设计教程，介绍常见的设计原则、设计模式、UML建模方法等内容，帮助你构建高质量的软件系统。...","permalink":"/post/software-design-tutorial","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"软件工程","slug":"软件工程","count":2,"path":"api/categories/软件工程.json"},{"name":"软件设计","slug":"软件工程/软件设计","count":2,"path":"api/categories/软件工程/软件设计.json"},{"name":"系统架构","slug":"软件工程/软件设计/系统架构","count":1,"path":"api/categories/软件工程/软件设计/系统架构.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":2,"path":"api/tags/设计模式.json"},{"name":"软件设计","slug":"软件设计","count":2,"path":"api/tags/软件设计.json"},{"name":"系统架构","slug":"系统架构","count":2,"path":"api/tags/系统架构.json"},{"name":"需求分析","slug":"需求分析","count":1,"path":"api/tags/需求分析.json"},{"name":"UML建模","slug":"UML建模","count":1,"path":"api/tags/UML建模.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"深入浅出 Spring Boot JVM 调优技巧","uid":"83f1970d736543012f09207d43ab0a9f","slug":"spring-boot-jvm-tuning","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-jvm-tuning.json","keywords":null,"cover":"https://example.com/cover-images/spring-boot-jvm-tuning.png","text":"本文详细介绍了如何针对 Spring Boot 应用进行 JVM 调优，包括内存管理、垃圾回收器选择和性能监控工具的使用，帮助开发者构建高性能、稳定的后端服务。...","permalink":"/post/spring-boot-jvm-tuning","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"性能优化","slug":"后端开发/性能优化","count":6,"path":"api/categories/后端开发/性能优化.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"JVM调优","slug":"JVM调优","count":3,"path":"api/tags/JVM调优.json"},{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"},{"name":"内存管理","slug":"内存管理","count":1,"path":"api/tags/内存管理.json"},{"name":"性能监控","slug":"性能监控","count":1,"path":"api/tags/性能监控.json"},{"name":"Java性能","slug":"Java性能","count":1,"path":"api/tags/Java性能.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true}}