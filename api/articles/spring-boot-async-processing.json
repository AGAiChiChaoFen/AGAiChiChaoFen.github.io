{"title":"Spring Boot 异步处理优化技巧","uid":"5ee088f3a4e8f24a265d688274214f82","slug":"spring-boot-async-processing","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-async-processing.json","keywords":null,"cover":"https://example.com/cover-images/spring-boot-async.png","content":"<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>随着 Web 应用和服务请求量的增加，系统的响应速度和吞吐量显得尤为重要。异步处理作为提升系统性能和响应速度的一项关键技术，在<br>Spring Boot 中有着广泛的应用。通过异步执行时间消耗较长的任务，能够释放线程池资源，减少系统的阻塞，提升并发处理能力。本文将深入探讨如何在<br>Spring Boot 中实现异步处理，包括常见的异步策略、性能优化技巧和最佳实践。</p>\n<h1 id=\"1-Spring-Boot-中的异步处理\"><a href=\"#1-Spring-Boot-中的异步处理\" class=\"headerlink\" title=\"1. Spring Boot 中的异步处理\"></a>1. Spring Boot 中的异步处理</h1><p>Spring Boot 提供了一个简洁而强大的异步处理支持，开发者可以通过配置和注解快速实现异步执行。Spring 的异步处理主要依赖于<br><code>@Async</code> 注解、<code>Executor</code> 和 <code>ThreadPoolTaskExecutor</code> 来管理线程池。</p>\n<h2 id=\"1-1-启用异步支持\"><a href=\"#1-1-启用异步支持\" class=\"headerlink\" title=\"1.1 启用异步支持\"></a>1.1 启用异步支持</h2><p>在 Spring Boot 中启用异步支持非常简单，只需要在配置类上添加 <code>@EnableAsync</code> 注解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAsync</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(AsyncApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-使用-Async-注解\"><a href=\"#1-2-使用-Async-注解\" class=\"headerlink\" title=\"1.2 使用 @Async 注解\"></a>1.2 使用 <code>@Async</code> 注解</h2><p>一旦异步支持启用，就可以通过 <code>@Async</code> 注解标记需要异步执行的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">executeAsyncTask</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟一个耗时任务</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;异步任务完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<ul>\n<li><code>@Async</code> 注解标记的方法必须返回 <code>void</code> 或 <code>Future</code>、<code>CompletableFuture</code>、<code>ListenableFuture</code> 等类型。</li>\n<li>默认情况下，异步方法会在一个单独的线程中执行。</li>\n</ul>\n<h1 id=\"2-配置异步线程池\"><a href=\"#2-配置异步线程池\" class=\"headerlink\" title=\"2. 配置异步线程池\"></a>2. 配置异步线程池</h1><p>为了避免每次异步任务都使用默认线程池，建议开发者自定义线程池。Spring Boot 允许开发者通过配置文件或 Java 配置类定制线程池的大小和其他参数。</p>\n<h2 id=\"2-1-使用-ThreadPoolTaskExecutor\"><a href=\"#2-1-使用-ThreadPoolTaskExecutor\" class=\"headerlink\" title=\"2.1 使用 ThreadPoolTaskExecutor\"></a>2.1 使用 <code>ThreadPoolTaskExecutor</code></h2><p>在 Spring 中，<code>ThreadPoolTaskExecutor</code> 是管理线程池的核心组件，可以通过该类来配置线程池的大小、队列容量等属性。</p>\n<h3 id=\"配置示例：\"><a href=\"#配置示例：\" class=\"headerlink\" title=\"配置示例：\"></a>配置示例：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ThreadPoolTaskExecutor <span class=\"title function_\">taskExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ThreadPoolTaskExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolTaskExecutor</span>();</span><br><span class=\"line\">        executor.setCorePoolSize(<span class=\"number\">10</span>);  <span class=\"comment\">// 核心线程池大小</span></span><br><span class=\"line\">        executor.setMaxPoolSize(<span class=\"number\">50</span>);   <span class=\"comment\">// 最大线程池大小</span></span><br><span class=\"line\">        executor.setQueueCapacity(<span class=\"number\">100</span>); <span class=\"comment\">// 队列容量</span></span><br><span class=\"line\">        executor.setThreadNamePrefix(<span class=\"string\">&quot;async-thread-&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数解释</strong>：</p>\n<ul>\n<li><code>CorePoolSize</code>：核心线程池大小，线程池创建时就会初始化的线程数。</li>\n<li><code>MaxPoolSize</code>：最大线程池大小，线程池可容纳的最大线程数。</li>\n<li><code>QueueCapacity</code>：当线程池满时，任务会被提交到阻塞队列中，等待执行。</li>\n</ul>\n<h2 id=\"2-2-配置-application-yml\"><a href=\"#2-2-配置-application-yml\" class=\"headerlink\" title=\"2.2 配置 application.yml\"></a>2.2 配置 <code>application.yml</code></h2><p>Spring Boot 也支持通过配置文件来调整线程池的设置。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">task:</span></span><br><span class=\"line\">    <span class=\"attr\">execution:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">core-size:</span> <span class=\"number\">10</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"number\">50</span></span><br><span class=\"line\">        <span class=\"attr\">queue-capacity:</span> <span class=\"number\">100</span></span><br><span class=\"line\">    <span class=\"attr\">scheduling:</span></span><br><span class=\"line\">      <span class=\"attr\">pool:</span></span><br><span class=\"line\">        <span class=\"attr\">size:</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-异步方法返回类型\"><a href=\"#3-异步方法返回类型\" class=\"headerlink\" title=\"3. 异步方法返回类型\"></a>3. 异步方法返回类型</h1><p>Spring Boot 的异步方法可以返回多种类型，常见的返回类型包括 <code>Future</code>、<code>CompletableFuture</code> 和 <code>ListenableFuture</code><br>，这些类型允许开发者更精确地控制异步任务的结果和状态。</p>\n<h2 id=\"3-1-使用-Future-类型\"><a href=\"#3-1-使用-Future-类型\" class=\"headerlink\" title=\"3.1 使用 Future 类型\"></a>3.1 使用 <code>Future</code> 类型</h2><p><code>Future</code> 是最基本的异步返回类型，表示一个可能尚未完成的计算任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Future&lt;String&gt; <span class=\"title function_\">executeTaskWithResult</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟耗时任务</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncResult</span>&lt;&gt;(<span class=\"string\">&quot;任务完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-使用-CompletableFuture-类型\"><a href=\"#3-2-使用-CompletableFuture-类型\" class=\"headerlink\" title=\"3.2 使用 CompletableFuture 类型\"></a>3.2 使用 <code>CompletableFuture</code> 类型</h2><p><code>CompletableFuture</code> 提供了更加灵活的异步任务控制，允许通过回调函数来处理任务完成后的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Async</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"title function_\">executeAsyncWithFuture</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 模拟耗时任务</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> CompletableFuture.completedFuture(<span class=\"string\">&quot;异步任务完成&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CompletableFuture.failedFuture(<span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>(<span class=\"string\">&quot;任务失败&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-异步任务的异常处理\"><a href=\"#4-异步任务的异常处理\" class=\"headerlink\" title=\"4. 异步任务的异常处理\"></a>4. 异步任务的异常处理</h1><p>在异步方法中处理异常相对复杂，因为异常不会直接传播到调用者线程。为了处理这些异常，可以通过自定义<br><code>AsyncUncaughtExceptionHandler</code> 来捕获并处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> AsyncUncaughtExceptionHandler <span class=\"title function_\">asyncExceptionHandler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncUncaughtExceptionHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">handleUncaughtException</span><span class=\"params\">(Throwable throwable, Method method, Object... obj)</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;异步方法发生异常: &quot;</span> + throwable.getMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-异步处理的最佳实践\"><a href=\"#5-异步处理的最佳实践\" class=\"headerlink\" title=\"5. 异步处理的最佳实践\"></a>5. 异步处理的最佳实践</h1><h2 id=\"5-1-限制线程池大小\"><a href=\"#5-1-限制线程池大小\" class=\"headerlink\" title=\"5.1 限制线程池大小\"></a>5.1 限制线程池大小</h2><p>过大的线程池会导致系统资源浪费，过小的线程池则会造成线程阻塞。合理配置线程池大小是非常重要的，可以根据实际业务量调整。</p>\n<h2 id=\"5-2-控制异步任务的执行顺序\"><a href=\"#5-2-控制异步任务的执行顺序\" class=\"headerlink\" title=\"5.2 控制异步任务的执行顺序\"></a>5.2 控制异步任务的执行顺序</h2><p>对于有顺序依赖的异步任务，可以通过 <code>CompletableFuture</code> 链式调用来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CompletableFuture.supplyAsync(() -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">task1())</span><br><span class=\"line\">        .</span><br><span class=\"line\"></span><br><span class=\"line\">thenApplyAsync(result -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">task2(result))</span><br><span class=\"line\">        .</span><br><span class=\"line\"></span><br><span class=\"line\">thenAcceptAsync(finalResult -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">task3(finalResult));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-使用-Async-与数据库事务结合时要谨慎\"><a href=\"#5-3-使用-Async-与数据库事务结合时要谨慎\" class=\"headerlink\" title=\"5.3 使用 @Async 与数据库事务结合时要谨慎\"></a>5.3 使用 <code>@Async</code> 与数据库事务结合时要谨慎</h2><p>异步方法中不会自动支持事务，所以在异步方法中使用数据库操作时需要特别注意事务的管理。</p>\n<h1 id=\"6-结语\"><a href=\"#6-结语\" class=\"headerlink\" title=\"6. 结语\"></a>6. 结语</h1><p>Spring Boot 提供了强大的异步处理支持，通过合理的线程池配置和返回类型选择，开发者可以高效地处理并发任务，提升系统的吞吐量和响应速度。同时，掌握异步任务的异常处理、线程池管理和性能优化策略将帮助你设计出更加稳定和高效的系统。</p>\n","feature":true,"text":"本文详细介绍了如何在 Spring Boot 中实现异步处理，分析了常见的异步处理策略，并给出了性能优化和最佳实践，帮助开发者提升系统响应速度和并发处理能力。...","permalink":"/post/spring-boot-async-processing","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"性能优化","slug":"后端开发/性能优化","count":6,"path":"api/categories/后端开发/性能优化.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"性能优化","slug":"性能优化","count":7,"path":"api/tags/性能优化.json"},{"name":"异步处理","slug":"异步处理","count":3,"path":"api/tags/异步处理.json"},{"name":"并发编程","slug":"并发编程","count":1,"path":"api/tags/并发编程.json"},{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Spring-Boot-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1. Spring Boot 中的异步处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%90%AF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">1.1 启用异步支持</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E4%BD%BF%E7%94%A8-Async-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">1.2 使用 @Async 注解</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">2. 配置异步线程池</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E4%BD%BF%E7%94%A8-ThreadPoolTaskExecutor\"><span class=\"toc-text\">2.1 使用 ThreadPoolTaskExecutor</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B%EF%BC%9A\"><span class=\"toc-text\">配置示例：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E9%85%8D%E7%BD%AE-application-yml\"><span class=\"toc-text\">2.2 配置 application.yml</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3. 异步方法返回类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%BD%BF%E7%94%A8-Future-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.1 使用 Future 类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E4%BD%BF%E7%94%A8-CompletableFuture-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.2 使用 CompletableFuture 类型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4. 异步任务的异常处理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">5. 异步处理的最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E9%99%90%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F\"><span class=\"toc-text\">5.1 限制线程池大小</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E6%8E%A7%E5%88%B6%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">5.2 控制异步任务的执行顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E4%BD%BF%E7%94%A8-Async-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%BB%93%E5%90%88%E6%97%B6%E8%A6%81%E8%B0%A8%E6%85%8E\"><span class=\"toc-text\">5.3 使用 @Async 与数据库事务结合时要谨慎</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E7%BB%93%E8%AF%AD\"><span class=\"toc-text\">6. 结语</span></a></li></ol>","author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"软件设计师教程：成为优秀设计师的路径","uid":"24e600ae0f784944e69c41a12f9fd883","slug":"software-designer-tutorial","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/software-designer-tutorial.json","keywords":null,"cover":"https://example.com/cover-images/software-designer.png","text":"本文将带你深入了解软件设计师的职业路径，涵盖软件设计的基本原则、核心技能、常见工具以及提升设计能力的实践技巧。...","permalink":"/post/software-designer-tutorial","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"软件工程","slug":"软件工程","count":2,"path":"api/categories/软件工程.json"},{"name":"软件设计","slug":"软件工程/软件设计","count":2,"path":"api/categories/软件工程/软件设计.json"},{"name":"职业发展","slug":"软件工程/软件设计/职业发展","count":1,"path":"api/categories/软件工程/软件设计/职业发展.json"}],"tags":[{"name":"软件设计","slug":"软件设计","count":2,"path":"api/tags/软件设计.json"},{"name":"设计原则","slug":"设计原则","count":1,"path":"api/tags/设计原则.json"},{"name":"系统架构","slug":"系统架构","count":2,"path":"api/tags/系统架构.json"},{"name":"职业发展","slug":"职业发展","count":1,"path":"api/tags/职业发展.json"},{"name":"工具使用","slug":"工具使用","count":1,"path":"api/tags/工具使用.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"Spring Boot 数据库优化实战","uid":"da282162e3762aeb9ca6ed290877c2e2","slug":"spring-boot-database-optimization","date":"2024-02-01T16:00:00.000Z","updated":"2024-02-01T16:00:00.000Z","comments":true,"path":"api/articles/spring-boot-database-optimization.json","keywords":null,"cover":"https://example.com/cover-images/spring-boot-database-optimization.png","text":"本文系统讲解了如何在Spring Boot应用中优化数据库性能，包括连接池配置、SQL调优、索引使用和缓存策略等，助力开发者提升系统响应速度与稳定性。...","permalink":"/post/spring-boot-database-optimization","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":14,"path":"api/categories/后端开发.json"},{"name":"数据库优化","slug":"后端开发/数据库优化","count":1,"path":"api/categories/后端开发/数据库优化.json"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","count":11,"path":"api/tags/Spring-Boot.json"},{"name":"数据库优化","slug":"数据库优化","count":3,"path":"api/tags/数据库优化.json"},{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"HikariCP","slug":"HikariCP","count":1,"path":"api/tags/HikariCP.json"},{"name":"SQL调优","slug":"SQL调优","count":1,"path":"api/tags/SQL调优.json"},{"name":"缓存策略","slug":"缓存策略","count":5,"path":"api/tags/缓存策略.json"},{"name":"性能调优","slug":"性能调优","count":2,"path":"api/tags/性能调优.json"}],"author":{"name":"广","slug":"blog-author","avatar":"https://sky-take-out-agaichichaofen.oss-cn-wuhan-lr.aliyuncs.com/qq%E5%A4%B4%E5%83%8F.jpg","link":"/","description":"啊广的读书交流自习室","socials":{"github":"https://github.com/AGAiChiChaoFen","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://www.weibo.com/u/5348126242","zhihu":"https://www.zhihu.com/people/wei-xin-yong-hu-92-31-83-82","csdn":"https://blog.csdn.net/m0_74151385?spm=1000.2115.3001.5343","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/501025927?spm_id_from=333.1007.0.0"}}}},"feature":true}}